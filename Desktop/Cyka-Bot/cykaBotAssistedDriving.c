#pragma config(Sensor, in1,    goalPot,        sensorPotentiometer)
#pragma config(Sensor, in2,    liftPot,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  lDriveEnc,      sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rDriveEnc,      sensorQuadEncoder)
#pragma config(Motor,  port1,           lChain,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           lyDrive,       tmotorVex393HighSpeed_MC29, openLoop, reversed, driveLeft, encoderPort, dgtl1)
#pragma config(Motor,  port3,           mlDrive,       tmotorVex393HighSpeed_MC29, openLoop, driveLeft, encoderPort, dgtl1)
#pragma config(Motor,  port4,           lLift,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           lGoal,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           rLift,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           rGoal,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           mrDrive,       tmotorVex393HighSpeed_MC29, openLoop, reversed, driveRight, encoderPort, dgtl3)
#pragma config(Motor,  port9,           ryDrive,       tmotorVex393HighSpeed_MC29, openLoop, driveRight, encoderPort, dgtl3)
#pragma config(Motor,  port10,          rChain,        tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

typedef enum ARRAY_INDEX { L_DRIVE = 0, R_DRIVE = 1, GOAL = 2, LIFT = 3, CHAIN = 4 };
typedef enum STICK_AXIS { RX = 0, RY = 1, LY = 2, LX = 3 };

void setDrive(short lPwr, short rPwr) {
	motor[lyDrive] =
		motor[mlDrive] =
		lPwr;
	motor[ryDrive] =
		motor[mrDrive] =
		rPwr;
}

void setLift(int pwr) {
	motor[lLift] =
		motor[rLift] =
		pwr;
}

void setChain(int pwr) {
	motor[lChain] =
		motor[rChain] =
		pwr;
}

void setGoal(int pwr) {
	motor[lGoal] =
		motor[rGoal] =
		pwr;
}

typedef struct {
	int targ,
		val,
		valLast,
		err,
		errLast,
		time,
		timeLast,
		dt,
		out;
	float kP,
		kI,
		kD,
		prop,
		integ,
		deriv,
		integLim;
} Pid;

Pid* initPid(Pid* pid, float kP, float kI, float kD, float integLim) {
		pid->targ =
			pid->val =
			pid->valLast =
			pid->err =
			pid->errLast =
			pid->time =
			pid->dt =
			pid->out =
			0;

		pid->time = nSysTime;

		pid->kP = kP;
		pid->kI = kI;
		pid->kD = kD;
		pid->integLim = integLim;

		return pid;
}

void setTarg(Pid* pid, int targ) {
	pid->integ = 0;
	pid->targ = targ;
}

Pid Pids[5];
float ks[5][3] = {
	{ 0.1, 0.001, 0.01},
	{ 0.1, 0.001, 0.01},
	{ 0.1, 0.001, 0.01},
	{ 0.1, 0.01, 0.01},
	{ 0.1, 0.01, 0.01}
};

task main() {
	static short sticks[4],
		mtrPwrs[5];

	for(int i = 0; i < 5; i++) {
		initPid((Pids+1),
	}

	while(true) {
		for(int i = 0; i < 4; i++) {
			if(fabs(vexRT[i]) > 11)
				sticks[i] = vexRT[i];
			else
				sticks[i] = 0;
		}

		mtrPwrs[L_DRIVE] = sticks[LY] + sticks[RX];
		mtrPwrs[R_DRIVE] = sticks[LY] - sticks[RX];
		mtrPwrs[LIFT] = (vexRT[Btn5U] ^ vexRT[Btn5D])
			? (vexRT[Btn5U])
				? 127
				: -127
			: 0;
		mtrPwrs[CHAIN] = (vexRT[Btn6U] ^ vexRT[Btn6D])
			? (vexRT[Btn6U])
				? 127
				: -127
			: 0;
		mtrPwrs[GOAL] = (vexRT[Btn8U] ^ vexRT[Btn8D])
			? (vexRT[Btn8U])
				? 127
				: -127
			: 0;

		setDrive(mtrPwrs[L_DRIVE], mtrPwrs[R_DRIVE]);
		setLift(mtrPwrs[LIFT]);
		setChain(mtrPwrs[CHAIN]);
		setGoal(mtrPwrs[GOAL]);

		wait1Msec(20);

	}


}
